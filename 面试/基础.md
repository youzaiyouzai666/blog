# 0.1 + 0.2 != 0.3

> 思路：浮点数存储机制，解决浮点数精度问题

### 逐字稿：

根本原因是，JavaScript 存储浮点数时，会使用 IEEE 754 标准的 64 位双精度浮点数格式，这会导致一些精度问题。
0.1 与 0.2 都是无限循环小数，它们在二进制中都是无限循环的，所以它们在转换为十进制时，会无限接近 0.3，但永远无法等于 0.3。

解决方案：使用将小数转为整数。

```
function getLength(num){
    return (num + '').split('.')?.[0].length
}
// 加法，先小数转为整数，相加后，再将结果转为小数
function add(num1, num2){
  // 先获取最大小数位数
  const maxLength = Math.pow(10, Math.max(getLength(num1), getLength(num2)))
  return (num1 * maxLength + num2 * maxLength)/ maxLength
}
add(0.1, 0.2)
```

```
// 允许误差在 Number.EPSILON 范围内视为相等
function equal(a, b) {
  return Math.abs(a - b) < Number.EPSILON; // 默认误差阈值约 2.22e-16
}
console.log(equal(0.1 + 0.2, 0.3)); // true
```

### 延伸

JavaScript 能精准保存的小数是

- 如果一个小数可以用有限的二进制位表示，则它可以被精准保存。
- 也就是说，如果一个小数可以用最简分数，分母是 2 的幂次方

# 创建 length 长度为 10w 的数组

> 思路：两种方案浏览器数组存储机制，以 v8 为例子

### 逐字稿：

数组是一种用于存储有序数据集合的对象。虽然数组看起来像简单的线性数据结构，但它的底层实现和存储方式涉及到 JavaScript 的动态特性以及内存管理机制。以下是关于 JavaScript 数组存储的详细解释：
JavaScript 数组的底层存储机制在不同引擎中实现不同，以 V8 引擎为例，其核心设计通过两种模式优化性能与内存使用： 连续数组和稀疏数组
连续数组

```
const array = new Array(1e5).fill(null); // 创建一个长度为 10000000 的连续数组
console.log(array); // 输出：[null × 10000000]
```

稀疏数组

```
const sparseArray = new Array(1e5); // 创建一个长度为 5 的稀疏数组
console.log(sparseArray); // 输出：[empty × 5]
```
